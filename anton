#!/usr/bin/env perl
use strict;
use warnings;

# bootstrapping...
#
# Do not load any modules before bootstrapping.
BEGIN {
    # mkdir -p anton/
    mkdir 'anton';
    mkdir 'anton/selfdeps/';

    # Write cpanfile for bootstrapping deps.
    my $cpanfile = 'anton/selfdeps/cpanfile';
    open my $fh, '>', $cpanfile
        or die "$cpanfile: $!";
    print {$fh} join("\n",
        "requires 'File::pushd', '1.005';",
        "requires 'OrePAN2', '0.21';",
        "requires 'IO::File::AtomicChange', '0.05';",
        "requires 'Module::CPANfile', '1.0905';",
    );
    close $fh;

    my @cmd = (
        'cpanm', '--quiet', '--dev', '--notest', '--no-man-pages',
        '-l', 'anton/selfdeps', '--cpanfile', $cpanfile, '--installdeps',
        '.',
    );
    system(@cmd) == 0 or die "Cannot install bootstrapping deps";
}
use File::Spec;
use lib File::Spec->rel2abs('anton/selfdeps/lib/perl5/');

package Anton::Snapshot {
    use Config;
    use JSON::PP;
    use ExtUtils::MakeMaker;

    our $IGNORE_RE;
    BEGIN {
        $IGNORE_RE = qr{\A(?:testdir|t|xt|local|perl5|fatlib|extras|test|inc|contrib|_build)/};
    }

    sub new {
        my $class = shift;
        my %args = @_==1 ? %{$_[0]} : @_;
        bless {
            ignore => {
                # Imager::File::PNG included in Imager-File-PNG-XXX.tar.gz and Imager-XXX.tar.gz. Very confusing.
                'Imager::File::JPEG' => 1,
                'Imager::File::PNG'  => 1,
            },
            directory => 'local',
            %args,
        }, $class;
    }

    sub json_files {
        my $self = shift;
        sort glob("$self->{directory}/lib/perl5/$Config{archname}/.meta/*/install.json");
    }

    sub load_json {
        my $fname = shift;

        open my $fh, '<', $fname
            or do {
            print "[anton] [WARN] Cannot open '$fname' for reading: $!\n";
            return;
        };

        my $json = do { local $/; <$fh> };
        return JSON::PP::decode_json($json);
    }

    sub aggregate {
        my ($self, $index) = @_;

        my %required;

        my @modules = (
            grep { $self->is_installed($_) }
            grep { defined $_ }
            map { load_json($_) }
            $self->json_files
        );

        for my $module (@modules) {
            for my $pkg (sort keys %{$module->{provides}}) {
                next unless $module->{provides}{$pkg}{file};
                next if $module->{provides}{$pkg}{file} =~ $IGNORE_RE;
                next if $self->{ignore}{$pkg};

                $index->add_index(
                    $pkg,
                    $module->{provides}->{$pkg}->{version},
                    $module->{pathname}
                );
            }
        }
    }

    sub is_installed {
        my ($self, $dat) = @_;

        # - All modules are installed.
        # - One or more modules are installed.
        # - If the file contains a correct package, ignore other package names.
        #   - Because inner package can't parse by EU::MM#parse_version

        my %file2pkgs;
        for my $package (keys %{$dat->{provides}}) {
            my $info = $dat->{provides}->{$package};
            next if $info->{file} =~ $IGNORE_RE;
            $file2pkgs{$info->{file}}{$package} = $info->{version};
        }

        FILE_LOOP:
        while (my ($file, $info) = each %file2pkgs) {
            while (my ($package, $version) = each %$info) {
                my $module = $package;
                $module =~ s!::!/!g;
                $module .= ".pm";

                for my $dir ("$self->{directory}/lib/perl5/", "$self->{directory}/lib/perl5/$Config{archname}/") {
                    my $path = "$dir/$module";
                    if (-f $path) {
                        my $version = MM->parse_version($path);

                        if (
                            version->parse($dat->{provides}->{$package}{version} // 0) == version->parse($version // 0)
                        ) {
                            next FILE_LOOP;
                        } else {
                            next;
                        }
                    }
                }
            }
            return 0;
        }
        return 1;
    }
}

package Anton {
    use File::Spec;
    use File::Temp;

    sub new {
        my $class = shift;
        my %args = @_==1 ? %{$_[0]} : @_;
        bless {
            mirror => $ENV{ANTON_CPAN_MIRROR} || 'http://ftp.riken.jp/lang/CPAN/',
            local  => 'local',
            cpanfile => 'cpanfile',
            %args,
        }, $class;
    }

    sub cpanfile { shift->{cpanfile} }

    sub verbose { shift->{verbose} }

    sub local_mirror_dir {
        my $self = shift;
        File::Spec->rel2abs("anton/mirror/");
    }

    sub local_mirror_uri {
        my $self = shift;
        'file://' . $self->local_mirror_dir;
    }

    sub darkpan_uri {
        my $self = shift;
        'file://' . File::Spec->rel2abs('anton/darkpan');
    }

    sub index_file {
        File::Spec->rel2abs('anton/index.txt')
    }

    sub merged_index_file {
        File::Spec->rel2abs('anton/merged.txt')
    }

    sub cache_dir { shift->local_mirror_dir }

    sub build_merged_index {
        my $self = shift;

        $self->infof("Building merged index");

        require OrePAN2::Index;
        my $index = OrePAN2::Index->new(
            no_mtime => 1,
        );
        if (-f $self->index_file) {
            $index->load($self->index_file);
        }
        if (-f $self->darkpan_index_file) {
            $index->load($self->darkpan_index_file, { replace => 1 });
        }
        $self->atomic_write($self->merged_index_file, $index->as_string());
    }

    sub install {
        my ($self, %args) = @_;

        unless (-f $self->cpanfile) {
            die "[anton] There is no cpanfile. Retried.\n";
        }

        # Make darkpan from anton/darkpan.txt
        $self->make_darkpan;

        $self->build_merged_index();

        # Re-create local/ directory using index file.
        if (-f $self->index_file) {
            printf "[anton] Installing modules with %s\n", $self->index_file;

            $self->run_cmd(
                "cpanm",
                '-L' => $self->{local},
                '--notest',
                '--no-man-pages',
                '--mirror' => $self->darkpan_uri,
                '--mirror' => $self->local_mirror_uri,
                '--mirror' => $self->{mirror},
                '--mirror' => 'http://backpan.perl.org/',
                '--mirror-index' => $self->merged_index_file,
                '--mirror-only',
                '--cpanfile' => $self->cpanfile,
                '--save-dists' => $self->cache_dir,
                ($self->verbose ? ('--verbose') : ()),
                '--installdeps' => '.'
            );
        } else {
            if ($args{deployment}) {
                die "You specified deployment mode. But there is no index file!\n";
            }
        }

        # Install dependent modules, and update index file.
        unless ($args{deployment}) {
            $self->run_cmd(
                "cpanm",
                '-L' => $self->{local},
                '--mirror' => $self->darkpan_uri,
                '--mirror' => $self->local_mirror_uri,
                '--mirror' => $self->{mirror},
                '--mirror' => 'http://backpan.perl.org/',
                '--mirror-index' => $self->merged_index_file,
                '--cascade-search',
                '--notest',
                '--no-man-pages',
                '--save-dists' => $self->cache_dir,
                '--cpanfile' => $self->cpanfile,
                ($self->verbose ? ('--verbose') : ()),
                '--installdeps' => '.'
            );

            $self->rebuild_index;
        }
    }

    sub make_darkpan {
        my $self = shift;

        my @repos = $self->darkpan_repos_from_cpanfile;
        return unless @repos;

        my $cache = $self->read_darkpan_cache;
        my $modified_darkpan = 0;
        for my $repo (@repos) {
            $self->debugf("Checking $repo");

            # Is there the dist file?
            my $mod = $cache->{$repo};
            my $hit_cache = sub {
                return 0 unless $mod;
                return 0 unless $mod->{file};
                return 0 unless $mod->{md5hex};
                return 0 unless -r $mod->{file};

                my $md5 = $self->calc_md5($mod->{file});
                return 0 unless $md5;
                return 0 if $md5 ne $mod->{md5hex};
                return 1;
            }->();
            if ($hit_cache) {
                $self->debugf("${repo} is fresh.");
            } else {
                $cache->{$repo} = $self->inject_to_darkpan($repo, $mod);
                $modified_darkpan++;
            }
        }

        return unless $modified_darkpan;

        # write anton/darkpan.json
        $self->atomic_write('anton/darkpan/cache.json', JSON::PP->new->pretty(1)->canonical(1)->encode($cache));

        # Make darkpan index.
        require OrePAN2::Indexer;
        my $indexer = OrePAN2::Indexer->new(
            directory => 'anton/darkpan',
        );
        $indexer->make_index;
    }

    sub atomic_write {
        my ($self, $filename, $content) = @_;

        $self->debugf("Writing ${filename}");
        File::Path::mkpath(File::Basename::dirname($filename));

        require IO::File::AtomicChange;
        my $fh = IO::File::AtomicChange->new($filename, 'w');
        $fh->print($content);
        $fh->close(); # MUST CALL close EXPLICITLY
    }

    sub calc_md5 {
        my ($self, $filename) = @_;

        open my $fh, '<', $filename
            or do {
            $self->warnf("Cannot open '$filename' for writing: $!");
            return;
        };

        require Digest::MD5;
        my $md5 = Digest::MD5->new();
        $md5->addfile($fh);
        $md5->hexdigest;
    }

    sub inject_to_darkpan {
        my ($self, $repo) = @_;

        require OrePAN2::Injector;

        my $inject = OrePAN2::Injector->new(directory => 'anton/darkpan');
        my $tarpath = $inject->inject($repo);
        $self->infof("Generated $tarpath from $repo");

        my $file = "anton/darkpan/$tarpath";
        unless (-f $file) {
            $self->croakf("There is no $file");
        }

        +{
            file => $file,
            md5hex => $self->calc_md5($file),
        };
    }

    sub read_darkpan_cache {
        my $self = shift;
        return +{ } unless -r 'anton/darkpan/cache.json';

        open my $fh, '<', 'anton/darkpan/cache.json'
            or return +{};
        return JSON::PP::decode_json(do { local $/; <$fh> });
    }

    sub darkpan_repos_from_cpanfile {
        my $self = shift;

        require Module::CPANfile;

        my $cpanfile = Module::CPANfile->load('cpanfile');

        my @repos;
        for my $module ($cpanfile->prereqs->merged_requirements->required_modules) {
            my $opts = $cpanfile->options_for_module($module);
            if ($opts->{git}) {
                push @repos, $opts->{git} . '@' . $opts->{ref};
            }
        }
        return @repos;
    }

    sub uninstall {
        my ($self, %args) = @_;

        for my $module (@{$args{modules}}) {
            system("cpanm", "-L", $self->{local}, '-U', $module);
        }

        $self->rebuild_index;
    }

    sub darkpan_index_file { 'anton/darkpan/modules/02packages.details.txt.gz' }

    sub rebuild_index {
        my $self = shift;

        require OrePAN2::Index;
        my $index = OrePAN2::Index->new();
        $index->no_mtime(1);

        my $snapshot = Anton::Snapshot->new(
            directory => $self->{local},
        );
        $snapshot->aggregate($index);
        $self->atomic_write($self->index_file, $index->as_string);
    }

    sub run_cmd {
        my ($self, @cmd) = @_;

        $self->infof("@cmd");
        if ($self->{dry_run}) {
            $self->infof("DRY RUN");
            return;
        }
        system(@cmd) == 0 or $self->croakf("Retired.");
    }

    sub write_gitignore_file {
        my $self = shift;

        my $filename = 'anton/.gitignore';
        unless (-f $filename) {
            $self->atomic_write(
                $filename,
                join("\n",
                    '/darkpan/',
                    '/mirror/',
                    '/selfdeps/',
                    '/merged.txt',
                )
            );
        }
    }

    my $colored = -t *STDOUT && eval "require Term::ANSIColor;1;" ? \&Term::ANSIColor::colored : sub { $_[1] };

    sub infof {
        my ($self, $fmt, @args) = @_;
        my $str = sprintf($fmt, @args);
        $str = $colored->(['blue'], $str);
        printf "[info] %s\n", $str;
    }

    sub croakf {
        my ($self, $fmt, @args) = @_;
        my $str = sprintf($fmt, @args);
        $str = $colored->(['red'], $str);
        Carp::croak(sprintf "[die] %s\n", $str);
    }

    sub warnf {
        my ($self, $fmt, @args) = @_;
        my $str = sprintf($fmt, @args);
        $str = $colored->(['yellow'], $str);
        printf "[warn] %s\n", $str;
    }

    sub debugf {
        my ($self, $fmt, @args) = @_;
        return unless $self->{debug};

        my $str = sprintf($fmt, @args);
        $str = $colored->(['green'], $str);
        printf "[debug] %s\n", $str;
    }
}

package Anton::CLI {
    use Pod::Usage;
    use Getopt::Long;
    use lib;
    use version;

    sub new {
        my ($class, $args) = @_;
        my $self = bless {
            args => $args,
        }, $class;
        $self->{anton} = $self->_build_anton();
        return $self;
    }

    sub anton { shift->{anton} }

    sub _build_anton {
        my $self = shift;

        my $p = Getopt::Long::Parser->new(
            config => [ "no_ignore_case", 'pass_through' ],
        );
        my $debug = $ENV{ANTON_DEBUG};
        my $local = 'local';
        $p->getoptionsfromarray(
            $self->{args},
            'dry-run!'    => \my $dry_run,
            'v|verbose!'  => \my $verbose,
            'debug!'      => \$debug,
            'local=s'     => \$local,
        );
        return Anton->new(
            dry_run => $dry_run,
            verbose => $verbose,
            debug   => $debug,
            local   => $local,
        );
    }

    sub run {
        my ($self) = @_;
        my $args = $self->{args};
        my $cmd = shift(@$args) || 'help';

        if ($self->can("CMD_${cmd}")) {
            $self->${\"CMD_${cmd}"}($args);
        } else {
            $self->CMD_help();
        }
    }

    sub CMD_help {
        pod2usage(1);
    }

    sub CMD_install {
        my ($self) = @_;

        my $deployment = 0;

        my $p = Getopt::Long::Parser->new( config => [ "no_ignore_case" ], );
        $p->getoptionsfromarray(
            $self->{args},
            "deployment!" => \$deployment,
        );

        $self->anton->write_gitignore_file;
        $self->{anton}->install(
            deployment => $deployment,
        );
    }

    sub CMD_index {
        my ($self, $args) = @_;

        $self->{anton}->rebuild_index();
    }

    sub CMD_uninstall {
        my ($self, $args) = @_;

        my $anton = Anton->new();
        $anton->uninstall(modules => $args);
    }
}

{
    my $cli = Anton::CLI->new(\@ARGV);
    $cli->run();
}


__END__

=head1 NAME

anton - Yet another CPAN module manager for web applications.

=head1 SYNOPSIS

    > anton install

    > anton uninstall Acme::YakiniQ

=head1 DEVELOPMENT STATUS

Unstable.

=head1 DESCRIPTION

Yet another CPAN module manager for web applications.

=head1 USAGE

=head2 At first time.

You need to write the cpanfile, first.

Then, you run following command:

    > anton install

cpanm installs all dependent modules.

Anton generates anton/modules/02.packages.details.txt from local/lib/perl5/*/.meta/*/install.json.
It contains installed module's version information.

You can restore local/ from anton/index.txt.

=head2 Restore local/ from anton/index.txt

You can generate original environment's local/ from anton/index.txt.

    > anton install --deployment

This command install all modules described in anton/index.txt.

If all restoration is succeeded, exit status is 0.
If anton gets an error, exit status is non-zero value.

=head1 Directory structure

    - cpanfile
    + anton
        - darkpan.txt
        + darkpan
            + authors
            + dists
        + dists
            - 02.packages.details.txt
        + authors

=head1 FAQ

=head2 Is there an `carton exec` equivalent command?

There is no `carton exec` equivalent subcommand.
But you can do `perl -Mlib::core::only -Mlib=lib/perl5/ foo.pl`.

=head1 LICENSE

Copyright (C) Tokuhiro Matsuno.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

Tokuhiro Matsuno E<lt>tokuhirom@gmail.comE<gt>

